"""Define the ManyBosonFockState class."""
import itertools
import warnings

import numpy as np
import scipy.sparse

from .linalg_utilities import DimensionalityError, binom, fact, safe_dot
from .many_boson_states_utilities import (_mal_to_mol, _mol_to_mal,
                                          symmetrise_arrays)


def _num_states_partition_class(n_modes, partition_class):
    """Compute the number of states in a partition class.

    Takes an element of the output of `list_partition_classes` and
    returns the number of states corresponding to it.
    """
    # extract the number of bosons corresponding to the partition class
    n_bosons = sum(partition_class)
    # count the classes of occupation numbers
    counts = [len(list(g)) for _, g in itertools.groupby(partition_class)]
    # compute the product of the factorial of the elements of `counts`,
    # the multiply with the factorial of the number of remaining modes,
    # and return the factorial of the total number of modes divided by
    # the above number. This is a generalized binomial coefficient.
    mu_factor = np.prod(fact(counts)).astype(np.int64)
    mu_factor *= fact(n_modes - n_bosons)
    return fact(n_modes) // mu_factor


class ManyBosonFockState:
    r"""A single many-boson Fock state (like a_1^\dagger a_2^\dagger)."""

    def __init__(self, n_modes=None, mal=None, mol=None):
        """Initialise necessary properties."""
        # initialize class attributes
        self.mol = None
        self.mal = None
        self.n_modes = None
        self.n_bosons = None
        # only one between `mol` and `mal` must be given
        if mal is not None and mol is not None:
            raise ValueError('Only one between `mol` and `mal` must'
                             'be used.')
        # if the state is defined using a mode occupation list, the value of
        # `n_modes` is ignored
        if mol is not None:
            self.mol = mol
            self.n_modes = len(mol)
            self.n_bosons = sum(mol)
        # if instead a mode assignment list is given through `mal`, the value
        # of `n_modes`, if not None, is used to determine the total number of
        # modes in the state
        if mal is not None:
            if n_modes is not None and n_modes < max(mal):
                raise ValueError('The number of modes must be larger than the'
                                 ' mode numbers given with `mal`.')
            # the value of `self.n_modes` is taken from `n_modes` if given, or
            # assumed to be the higher mode in the given `mal` otherwise
            if n_modes is not None:
                self.n_modes = n_modes
            else:
                self.n_modes = max(mal)
            self.mal = tuple(sorted(mal))
            self.n_bosons = len(mal)

    def get_mol(self):
        """Get mode occupation list representing the state."""
        if self.mol is None:
            # if no mol was set, we obtain it's value from the saved mal
            self.mol = _mal_to_mol(self.mal, n_modes=self.n_modes)
        return self.mol

    def get_mal(self):
        """Get mode assignment list representing the state."""
        if self.mal is None:
            # generate the mal if not already done
            self.mal = _mol_to_mal(self.mol)
        return self.mal

    def get_mbs_amplitude(self):
        """Get the corresponding amplitude in the many-boson space."""
        amp = scipy.sparse.dok_matrix(
            (binom(self.n_modes, 2), 1), dtype=np.complex)
        amp[self._get_index_in_mbs()] = 1
        return amp

    def _get_index_in_mbs(self, order='mixed_order'):
        """Get index in the many-boson state corresponding to this mol.

        Returns the index corresponding to the current many-boson state in the
        full many-boson space with same number of bosons and modes.
        The order of the states in this space is assumed to be the same as that
        generated by `set(itertools.permutations(...)`.

        WARNING: the convention used here is different than the one used in
                 `ManyBosonProductState`, `symmetrise_arrays` etc.
        """
        if order == 'mixed_order':
            # With this ordering the many boson states are ordered according
            # to the following listing of mals:
            # (0, 0, 0), (0, 0, 1), (0, 0, 2), ..., (0, 0, m - 1),
            # (0, 1, 0), (0, 1, 1), (0, 1, 2), ..., (0, 1, m - 1), ...
            # (m - 1, m - 1, 0), (m - 1, m - 1, 1), ..., (m - 1, m - 1, m - 1),
            # where `m` is the number of modes, and the number of bosons is
            # here assumed to be 3.
            mal = self.get_mal()
            mbs_index = np.int64(0)
            prev_mode = 0
            for boson_index, mode_idx in enumerate(mal):
                for virtual_mode_idx in range(prev_mode, mode_idx):
                    mbs_index += scipy.special.binom(
                        (self.n_modes - virtual_mode_idx + self.n_bosons -
                         boson_index - 2), self.n_bosons - boson_index - 1)
                prev_mode = mode_idx
            return mbs_index.astype(int)
        elif order == 'cf_first':
            # With this ordering the many boson states are ordered as
            # dictated by the output of `_list_partition_classes`,
            # that is, all collision-free states are listed first, and
            # then progressively the more bunched states follow.

            # p_classes is the list of partition classes describing the
            # possible types of bunching
            p_classes = _list_partition_classes(self.n_bosons)
            # convert state mol to a partition class-like format
            mol = tuple(self.get_mol())
            stripped_mol = tuple(
                sorted([r for r in mol if r != 0], reverse=True))
            # see to which of the possible bunching class does the mol
            # correspond to
            actual_pclass = p_classes.index(stripped_mol)
            # set the counter to start count from the correct point
            counter = 0
            for prev_class_idx in range(actual_pclass):
                counter += _num_states_partition_class(
                    self.n_modes, p_classes[prev_class_idx])
            # now find the index of the mol inside the list of states
            # in the correct bunching class
            # states_in_pclass = sorted(list(set(itertools.permutations(mol))),
            #                           reverse=True)
            # counter += states_in_pclass.index(mol)
            if self.n_bosons != 2:
                raise NotImplementedError('Only implemented for 2 photons')
            mal_from_1 = tuple(1 + r for r in self.get_mal())
            counter = (mal_from_1[0] - 1) * (self.n_modes - mal_from_1[0] / 2)
            counter += mal_from_1[1] - mal_from_1[0] - 1
            counter = int(counter)

            return counter

    def evolve(self, matrix):
        """Evolve the state with the given evolution matrix.

        The evolution of the states is handled by the ManyBosonProductState
        class. This function thus converts the `ManyBosonFockState` into a
        `ManyBosonProductState` and calls the `evolve` method from there.
        """
        if matrix.shape[0] != self.n_modes:
            raise DimensionalityError('Modes mismatch, {} != {}.'.format(
                matrix.shape[0], self.n_modes))
        # mal contains the modes to load into the ManyBosonProductState object
        mal = self.get_mal()
        # take every boson specified in `mal` and inject it separately
        # as a new excitation for a `ManyBosonProductState` object
        mbs = ManyBosonProductState(self.n_modes)
        for boson_idx in mal:
            amplitudes = _mal_to_mol((boson_idx,), n_modes=self.n_modes)
            mbs.add_excitation(amplitudes)
        # actually evolve the state using `matrix`
        mbs.evolve(matrix)
        return mbs


class ManyBosonProductState:
    """Many boson product state object.

    This object is used to represent many-boson states that can be written as
    product of a number of creation operators (of given states).
    This representation can be more efficient for large number of modes, as
    it doesn't store the whole (exponentially large) many-boson state vector,
    but only the 1-body states of the single excitations.
    """

    def __init__(self, n_modes):
        """Initialize class variables."""
        self.n_modes = n_modes
        self.n_bosons = 0
        self.amplitudes = []  # list of amplitude vectors, 1 element per boson
        self.many_body_amplitudes = None

    def add_excitation(self, new_amplitude):
        """Add an excitation to the many boson state.

        The new amplitude is renormalized and then stored into
        `self.amplitudes`, and the `self.n_bosons` counter is updated.
        Nothing else is done by this function (renormalizations due to
        bunching are applied later when the many boson amplitudes are
        requested).
        """
        # check consistency of number of modes of added amplitude
        if new_amplitude.shape[0] != self.n_modes:
            raise ValueError('Incorrect number of modes: {} != {}.'.format(
                new_amplitude.shape[0], self.n_modes))
        # actually add new amplitude
        self.n_bosons += 1
        # normalize new amplitude
        new_amplitude = np.asarray(new_amplitude, dtype=np.complex)
        new_amplitude /= np.linalg.norm(new_amplitude)
        self.amplitudes.append(new_amplitude)
        # the following only makes sense for 2 bosons (not sure for more):
        # store normalization factor if the newly added amplitude is not
        # orthogonal
        # self.norm = np.abs(np.vdot(*self.amplitudes)) ^ 2
        # self.norm = np.sqrt(1 + self.norm)
        return self

    def remove_excitation(self, index_excitation):
        """Remove a specific interaction."""
        if self.n_bosons == 0:
            raise ValueError('There are no excitations left to remove.')

        del self.amplitudes[index_excitation]
        self.n_bosons -= 1
        return self

    def compute_many_boson_amplitudes(self):
        """Compute the corresponding symmetrised many boson state.

        This function *does not* return the computed amplitudes, it
        only stores them in `self.many_body_amplitudes`, and returns
        the same instance of the class.
        Use `get_many_boson_amplitudes` to compute *and* return the
        amplitudes.
        """
        amps = symmetrise_arrays(*self.amplitudes)
        self.many_body_amplitudes = amps

        return self

    def get_many_boson_amplitudes(self, joined=False):
        """Compute and return many boson amplitudes.

        Parameters
        ----------
        joined : bool
            If True, the many-boson amplitudes are returned as a single
            1d numpy array. Otherwise, the output is a dictionary with
            keys the various bunching classes and values the amplitudes
            corresponding to that bunching class.
        """
        mbs_dict = self.compute_many_boson_amplitudes().many_body_amplitudes
        if joined:
            return np.concatenate(tuple(amps for _, amps in mbs_dict.items()))
        else:
            return mbs_dict

    def evolve(self, matrix):
        """Evolve the many-boson state using the given evolution matrix."""
        for boson_index in range(self.n_bosons):
            self.amplitudes[boson_index] = matrix.dot(
                self.amplitudes[boson_index])
        return self
